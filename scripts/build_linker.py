#!/usr/bin/python

# This file is part of Espruino, a JavaScript interpreter for Microcontrollers
#
# Copyright (C) 2013 Gordon Williams <gw@pur3.co.uk>
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# ----------------------------------------------------------------------------------------
# Reads board information from boards/BOARDNAME.py and uses it to generate 
# a linker file
# ----------------------------------------------------------------------------------------
import subprocess;
import re;
import json;
import sys;
import os;
import importlib;

scriptdir = os.path.dirname(os.path.realpath(__file__))
basedir = scriptdir+"/../"
sys.path.append(basedir+"scripts");
sys.path.append(basedir+"boards");

import pinutils;

# -----------------------------------------------------------------------------------------

# Now scan AF file
print "Script location "+scriptdir

if len(sys.argv)!=3:
  print "ERROR, USAGE: build_linker.py BOARD_NAME LINKER_FILE"
  exit(1)
boardname = sys.argv[1]
linkerFilename = sys.argv[2]
print "LINKER_FILENAME "+linkerFilename
print "BOARD "+boardname
# import the board def
board = importlib.import_module(boardname)

# -----------------------------------------------------------------------------------------
linkerFile = open(linkerFilename, 'w')
def codeOut(s): linkerFile.write(s+"\n");
# -----------------------------------------------------------------------------------------
def die(err):
  print("ERROR: "+err)
  sys.exit(1)
# -----------------------------------------------------------------------------------------
RAM_BASE = 0x20000000;
FLASH_BASE = 0x08000000;
RAM_SIZE = board.chip["ram"]*1024;
FLASH_SIZE = board.chip["flash"]*1024;

codeOut("""
/* Automatically generated linker file for """+boardname+"""
   Generated by scripts/build_linker.py

ENTRY(Reset_Handler)

/* Highest stack address */
_estack = """+hex(RAM_BASE+RAM_SIZE)+""";

MEMORY
{
  FLASH (rx)      : ORIGIN = """+hex(FLASH_BASE)+""", LENGTH = """+str(FLASH_SIZE/1024)+"""K
  RAM (xrw)       : ORIGIN = """+hex(RAM_BASE)+""", LENGTH = """+str(RAM_SIZE/1024)+"""K
}

SECTIONS
{
  /* FLASH --------------------------------------------- */
  /* Interrupt Vector table goes first */
  .isr_vector :
  {
    . = ALIGN(0x200); /* STM32 requires this alignment */
    _VECTOR_TABLE = .; /* We'll need this for relocating our table */
    KEEP(*(.isr_vector))
    . = ALIGN(4);
  } >FLASH

  .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
    .ARM : {
    __exidx_start = .;
      *(.ARM.exidx*)
      __exidx_end = .;
  } >FLASH

  /* Then code, then constants */
  .text :
  {
    . = ALIGN(4);
    *(.text)  
    *(.text*) 
    *(.rodata)  
    *(.rodata*) 
    *(.glue_7)  
    *(.glue_7t) 

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;
  } >FLASH

  /* used by the startup to initialize data */
  _sidata = .;

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data : AT ( _sidata )
  {
    . = ALIGN(4);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(4);
    _edata = .;        /* define a global symbol at data end */
  } >RAM

  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss secion */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >RAM

  PROVIDE ( end = _ebss );
  PROVIDE ( _end = _ebss );

  /* Remove stuff we don't want */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }
}
""");

